import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest'
import { NextRequest } from 'next/server'
import { RateLimiter } from '@/lib/security/rate-limit'
import { validateInput, sanitizeInput } from '@/lib/security/input-sanitization'
import { 
  userRegistrationSchema,
  userLoginSchema,
  chatMessageSchema,
  playerActionSchema 
} from '@/lib/validation/schemas'

describe('Security Vulnerability Tests', () => {
  
  describe('SQL Injection Prevention', () => {
    it('should prevent SQL injection in login queries', async () => {
      const sqlInjectionPayloads = [
        "admin'; DROP TABLE users; --",
        "admin' OR '1'='1",
        "admin' UNION SELECT * FROM passwords --",
        "admin'; INSERT INTO users (username, password) VALUES ('hacker', 'pass'); --",
        "'; EXEC xp_cmdshell('dir'); --",
        "admin' AND (SELECT COUNT(*) FROM users) > 0 --"
      ]

      for (const payload of sqlInjectionPayloads) {
        // Test email field
        expect(() => {
          userLoginSchema.parse({
            email: payload,
            password: 'password123'
          })
        }).toThrow() // Should fail validation before reaching database

        // Test in raw query context (mocked)
        const mockQuery = vi.fn().mockImplementation((query: string, params: any[]) => {
          // Ensure parameterized queries are used
          expect(query).not.toContain(payload)
          expect(params).toContain(payload) // Should be in parameters, not query string
          return Promise.resolve([])
        })

        // This would be the actual database call
        await mockQuery(
          'SELECT * FROM users WHERE email = ? AND password = ?',
          [payload, 'password123']
        )

        expect(mockQuery).toHaveBeenCalledWith(
          expect.stringMataining('?'), // Should use placeholders
          expect.arrayContaining([payload])
        )
      }
    })

    it('should use parameterized queries for all database operations', async () => {
      const testCases = [
        {
          operation: 'getUserById',
          query: 'SELECT * FROM users WHERE id = ?',
          params: ["'; DROP TABLE users; --"]
        },
        {
          operation: 'updateUserProfile', 
          query: 'UPDATE users SET display_name = ? WHERE id = ?',
          params: ["<script>alert('xss')</script>", 'user-id']
        },
        {
          operation: 'searchGames',
          query: 'SELECT * FROM games WHERE name LIKE ? LIMIT ?',
          params: ["%'; DROP TABLE games; --%", 10]
        }
      ]

      testCases.forEach(({ operation, query, params }) => {
        // Verify parameterized query structure
        expect(query).toMatch(/\?/) // Should contain placeholders
        expect(query).not.toMatch(/['"]\s*\+|concat/i) // Should not use string concatenation
        
        // Verify dangerous input is in parameters, not query
        params.forEach(param => {
          if (typeof param === 'string' && param.includes(';')) {
            expect(query).not.toContain(param)
          }
        })
      })
    })

    it('should validate all database inputs', async () => {
      const dangerousInputs = [
        "'; DROP TABLE users; --",
        "UNION SELECT password FROM users",
        "1' OR '1'='1",
        "'; EXEC xp_cmdshell('rm -rf /'); --"
      ]

      dangerousInputs.forEach(input => {
        // User ID validation
        expect(() => {
          if (input.length !== 36) { // UUID length
            throw new Error('Invalid user ID format')
          }
        }).toThrow()

        // Game name validation  
        expect(() => {
          if (!/^[a-zA-Z0-9\s_-]+$/.test(input)) {
            throw new Error('Invalid characters in game name')
          }
        }).toThrow()

        // Email validation
        expect(() => {
          if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input)) {
            throw new Error('Invalid email format')
          }
        }).toThrow()
      })
    })
  })

  describe('Cross-Site Scripting (XSS) Prevention', () => {
    it('should sanitize user input in chat messages', () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<object data="javascript:alert(\'XSS\')"></object>',
        '<embed src="javascript:alert(\'XSS\')">',
        '<link rel="stylesheet" href="javascript:alert(\'XSS\')">',
        '<style>@import url("javascript:alert(\'XSS\')")</style>',
        '<div onmouseover="alert(\'XSS\')">Hover me</div>',
        'javascript:alert("XSS")',
        'data:text/html,<script>alert("XSS")</script>',
        '<META HTTP-EQUIV="refresh" CONTENT="0;url=javascript:alert(\'XSS\')">'
      ]

      xssPayloads.forEach(payload => {
        // Test chat message validation
        expect(() => {
          chatMessageSchema.parse({
            text: payload,
            sessionId: 'valid-uuid-here'
          })
        }).not.toThrow() // Should validate but content should be sanitized

        // Test input sanitization
        const sanitized = sanitizeInput(payload)
        expect(sanitized).not.toContain('<script>')
        expect(sanitized).not.toContain('javascript:')
        expect(sanitized).not.toContain('onerror=')
        expect(sanitized).not.toContain('onload=')
        expect(sanitized).not.toContain('onmouseover=')
      })
    })

    it('should escape HTML in user-generated content', () => {
      const htmlContent = [
        '<h1>Title</h1>',
        '<p>Paragraph with <strong>bold</strong> text</p>',
        '<a href="http://example.com">Link</a>',
        '<div class="dangerous">Content</div>',
        '&lt;script&gt;alert("test")&lt;/script&gt;'
      ]

      htmlContent.forEach(content => {
        const escaped = sanitizeInput(content)
        
        // Should escape HTML entities
        expect(escaped).not.toMatch(/<(?!\/?(b|i|strong|em)(?:\s|>))/g)
        if (content.includes('<')) {
          expect(escaped).toContain('&lt;')
        }
        if (content.includes('>')) {
          expect(escaped).toContain('&gt;')
        }
      })
    })

    it('should validate Content-Type headers', () => {
      const dangerousContentTypes = [
        'text/html',
        'application/x-javascript',
        'text/javascript',
        'application/javascript',
        'text/xml',
        'application/xml'
      ]

      const safeContentTypes = [
        'application/json',
        'text/plain',
        'multipart/form-data',
        'application/x-www-form-urlencoded'
      ]

      // API should only accept safe content types
      dangerousContentTypes.forEach(contentType => {
        const request = new NextRequest('http://localhost/api/test', {
          method: 'POST',
          headers: { 'Content-Type': contentType },
          body: '<script>alert("xss")</script>'
        })

        // Should reject or sanitize dangerous content types
        expect(request.headers.get('Content-Type')).toBe(contentType)
        // In actual implementation, this would be rejected
      })

      safeContentTypes.forEach(contentType => {
        const request = new NextRequest('http://localhost/api/test', {
          method: 'POST',
          headers: { 'Content-Type': contentType },
          body: 'safe content'
        })

        expect(request.headers.get('Content-Type')).toBe(contentType)
      })
    })

    it('should implement Content Security Policy headers', () => {
      const expectedCSP = [
        "default-src 'self'",
        "script-src 'self' 'unsafe-inline'", // Only if necessary
        "style-src 'self' 'unsafe-inline'",
        "img-src 'self' data: https:",
        "connect-src 'self' ws: wss:",
        "font-src 'self'",
        "object-src 'none'",
        "media-src 'self'",
        "frame-src 'none'"
      ].join('; ')

      // Mock response headers
      const mockHeaders = new Headers()
      mockHeaders.set('Content-Security-Policy', expectedCSP)

      expect(mockHeaders.get('Content-Security-Policy')).toContain("default-src 'self'")
      expect(mockHeaders.get('Content-Security-Policy')).toContain("object-src 'none'")
      expect(mockHeaders.get('Content-Security-Policy')).toContain("frame-src 'none'")
    })
  })

  describe('Cross-Site Request Forgery (CSRF) Prevention', () => {
    it('should validate CSRF tokens on state-changing requests', async () => {
      const stateChangingMethods = ['POST', 'PUT', 'PATCH', 'DELETE']

      stateChangingMethods.forEach(method => {
        // Request without CSRF token should be rejected
        const requestWithoutToken = new NextRequest('http://localhost/api/test', {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: 'test' })
        })

        // Should not have CSRF token
        expect(requestWithoutToken.headers.get('X-CSRF-Token')).toBeNull()
        
        // Request with invalid CSRF token should be rejected
        const requestWithInvalidToken = new NextRequest('http://localhost/api/test', {
          method,
          headers: { 
            'Content-Type': 'application/json',
            'X-CSRF-Token': 'invalid-token'
          },
          body: JSON.stringify({ data: 'test' })
        })

        expect(requestWithInvalidToken.headers.get('X-CSRF-Token')).toBe('invalid-token')
        // In actual implementation, this would be validated and rejected
      })
    })

    it('should validate Origin and Referer headers', () => {
      const allowedOrigins = [
        'http://localhost:3000',
        'https://pokerhome.app',
        'https://www.pokerhome.app'
      ]

      const dangerousOrigins = [
        'http://evil.com',
        'https://malicious-site.com',
        'http://localhost:3000.evil.com',
        'javascript:alert("xss")'
      ]

      allowedOrigins.forEach(origin => {
        const request = new NextRequest('http://localhost/api/test', {
          method: 'POST',
          headers: { 
            'Origin': origin,
            'Content-Type': 'application/json'
          }
        })

        expect(request.headers.get('Origin')).toBe(origin)
        // In actual implementation, this would be validated as safe
      })

      dangerousOrigins.forEach(origin => {
        const request = new NextRequest('http://localhost/api/test', {
          method: 'POST',
          headers: { 
            'Origin': origin,
            'Content-Type': 'application/json'
          }
        })

        expect(request.headers.get('Origin')).toBe(origin)
        // In actual implementation, this would be rejected
      })
    })

    it('should implement SameSite cookie attributes', () => {
      const cookieOptions = {
        httpOnly: true,
        secure: true,
        sameSite: 'strict' as const,
        maxAge: 86400 // 24 hours
      }

      // Verify cookie security attributes
      expect(cookieOptions.httpOnly).toBe(true) // Prevent XSS access
      expect(cookieOptions.secure).toBe(true)   // HTTPS only
      expect(cookieOptions.sameSite).toBe('strict') // Prevent CSRF
      expect(cookieOptions.maxAge).toBeGreaterThan(0)
    })
  })

  describe('Authentication and Authorization', () => {
    it('should prevent password enumeration attacks', async () => {
      const testCredentials = [
        { email: 'existing@example.com', password: 'wrongpassword' },
        { email: 'nonexistent@example.com', password: 'anypassword' },
        { email: 'admin@example.com', password: 'wrongpassword' }
      ]

      const responses: any[] = []

      for (const creds of testCredentials) {
        // Mock login attempt
        const mockResponse = {
          status: 401,
          message: 'Invalid email or password', // Same message for all failures
          timestamp: Date.now()
        }
        responses.push(mockResponse)
      }

      // All failed login attempts should return the same error message
      const uniqueMessages = [...new Set(responses.map(r => r.message))]
      expect(uniqueMessages).toHaveLength(1)
      expect(uniqueMessages[0]).toBe('Invalid email or password')

      // Response times should be similar (no timing attacks)
      const responseTimes = responses.map(r => r.timestamp)
      const maxTime = Math.max(...responseTimes)
      const minTime = Math.min(...responseTimes)
      expect(maxTime - minTime).toBeLessThan(100) // Within 100ms
    })

    it('should implement proper session management', () => {
      const sessionConfig = {
        // Session timeout
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
        
        // Session rotation
        rotateOnLogin: true,
        
        // Secure session storage
        httpOnly: true,
        secure: true,
        sameSite: 'strict' as const,
        
        // Session invalidation
        invalidateOnLogout: true,
        invalidateOnPasswordChange: true
      }

      expect(sessionConfig.maxAge).toBeGreaterThan(0)
      expect(sessionConfig.rotateOnLogin).toBe(true)
      expect(sessionConfig.httpOnly).toBe(true)
      expect(sessionConfig.secure).toBe(true)
      expect(sessionConfig.sameSite).toBe('strict')
      expect(sessionConfig.invalidateOnLogout).toBe(true)
      expect(sessionConfig.invalidateOnPasswordChange).toBe(true)
    })

    it('should validate JWT tokens properly', () => {
      const invalidTokens = [
        '', // Empty token
        'invalid.token.format',
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature',
        'Bearer ', // Empty bearer token
        'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.', // None algorithm
        'x'.repeat(1000) // Overly long token
      ]

      invalidTokens.forEach(token => {
        // Mock JWT validation
        const isValid = validateJWT(token)
        expect(isValid).toBe(false)
      })
    })

    it('should prevent privilege escalation', () => {
      const userRoles = {
        user: ['read:profile', 'update:own_profile'],
        moderator: ['read:users', 'moderate:games'],
        admin: ['read:all', 'write:all', 'delete:users'],
        super_admin: ['*']
      }

      // Test that users can't access admin functions
      const userPermissions = userRoles.user
      const adminOnlyActions = ['delete:users', 'read:all', 'write:all']

      adminOnlyActions.forEach(action => {
        expect(userPermissions).not.toContain(action)
      })

      // Test that moderators can't perform admin actions
      const moderatorPermissions = userRoles.moderator
      expect(moderatorPermissions).not.toContain('delete:users')
      expect(moderatorPermissions).not.toContain('write:all')
    })
  })

  describe('Input Validation and Sanitization', () => {
    it('should validate all user inputs', () => {
      const testCases = [
        {
          schema: userRegistrationSchema,
          validInput: {
            email: 'test@example.com',
            username: 'testuser',
            password: 'SecurePass123!@#'
          },
          invalidInputs: [
            { email: '', username: 'test', password: 'weak' },
            { email: 'invalid-email', username: '', password: 'SecurePass123!@#' },
            { email: 'test@example.com', username: 'test', password: '' }
          ]
        },
        {
          schema: playerActionSchema,
          validInput: {
            action: 'raise',
            amount: 50,
            sessionId: '550e8400-e29b-41d4-a716-446655440000',
            timestamp: new Date().toISOString()
          },
          invalidInputs: [
            { action: 'invalid_action', amount: 50, sessionId: 'valid-uuid', timestamp: 'now' },
            { action: 'raise', amount: -10, sessionId: 'valid-uuid', timestamp: 'now' },
            { action: 'raise', amount: 50, sessionId: 'invalid-uuid', timestamp: 'now' }
          ]
        }
      ]

      testCases.forEach(({ schema, validInput, invalidInputs }) => {
        // Valid input should pass
        expect(() => schema.parse(validInput)).not.toThrow()

        // Invalid inputs should fail
        invalidInputs.forEach(invalidInput => {
          expect(() => schema.parse(invalidInput)).toThrow()
        })
      })
    })

    it('should sanitize file upload inputs', () => {
      const dangerousFileNames = [
        '../../../etc/passwd',
        '..\\..\\windows\\system32\\config\\sam',
        'script.exe',
        'malware.bat',
        'virus.com',
        '<script>alert("xss")</script>.jpg',
        'normal.jpg.exe',
        'file with spaces and $pecial ch@rs!.jpg'
      ]

      dangerousFileNames.forEach(fileName => {
        const sanitized = sanitizeFileName(fileName)
        
        // Should not contain path traversal
        expect(sanitized).not.toContain('../')
        expect(sanitized).not.toContain('..\\')
        
        // Should not contain dangerous extensions
        const dangerousExtensions = ['.exe', '.bat', '.com', '.scr', '.pif']
        dangerousExtensions.forEach(ext => {
          expect(sanitized.toLowerCase()).not.toEndWith(ext)
        })
        
        // Should not contain script tags
        expect(sanitized).not.toContain('<script>')
        expect(sanitized).not.toContain('</script>')
      })
    })

    it('should validate file types and sizes', () => {
      const testFiles = [
        { name: 'image.jpg', size: 1024 * 1024, type: 'image/jpeg' }, // 1MB
        { name: 'large.jpg', size: 10 * 1024 * 1024, type: 'image/jpeg' }, // 10MB
        { name: 'script.js', size: 1024, type: 'application/javascript' },
        { name: 'document.pdf', size: 2 * 1024 * 1024, type: 'application/pdf' }
      ]

      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif']
      const maxSize = 5 * 1024 * 1024 // 5MB

      testFiles.forEach(file => {
        const isTypeAllowed = allowedTypes.includes(file.type)
        const isSizeValid = file.size <= maxSize

        if (file.name === 'image.jpg') {
          expect(isTypeAllowed).toBe(true)
          expect(isSizeValid).toBe(true)
        }

        if (file.name === 'large.jpg') {
          expect(isTypeAllowed).toBe(true)
          expect(isSizeValid).toBe(false) // Too large
        }

        if (file.name === 'script.js') {
          expect(isTypeAllowed).toBe(false) // Dangerous type
        }
      })
    })
  })

  describe('Rate Limiting and DoS Prevention', () => {
    it('should implement comprehensive rate limiting', async () => {
      const rateLimitTests = [
        {
          endpoint: 'authentication',
          limit: 5,
          window: 15 * 60 * 1000, // 15 minutes
          expectation: 'Should limit failed login attempts'
        },
        {
          endpoint: 'api',
          limit: 100,
          window: 60 * 1000, // 1 minute
          expectation: 'Should limit general API usage'
        },
        {
          endpoint: 'registration',
          limit: 3,
          window: 60 * 60 * 1000, // 1 hour
          expectation: 'Should limit new registrations'
        },
        {
          endpoint: 'chat',
          limit: 10,
          window: 60 * 1000, // 1 minute
          expectation: 'Should limit chat messages'
        }
      ]

      for (const test of rateLimitTests) {
        const identifier = `test-user-${Date.now()}`
        
        // Make requests up to limit
        for (let i = 0; i < test.limit; i++) {
          const result = await RateLimiter.checkRateLimit(identifier, {
            windowMs: test.window,
            maxRequests: test.limit
          })
          expect(result.allowed).toBe(true)
        }

        // Next request should be rate limited
        const limitedResult = await RateLimiter.checkRateLimit(identifier, {
          windowMs: test.window,
          maxRequests: test.limit
        })
        expect(limitedResult.allowed).toBe(false)
        expect(limitedResult.retryAfter).toBeGreaterThan(0)
      }
    })

    it('should prevent request flooding', async () => {
      const identifier = 'flood-test-user'
      const requests = []

      // Create 100 concurrent requests
      for (let i = 0; i < 100; i++) {
        requests.push(
          RateLimiter.checkRateLimit(identifier, {
            windowMs: 60000,
            maxRequests: 10
          })
        )
      }

      const results = await Promise.all(requests)
      const allowedRequests = results.filter(r => r.allowed)
      const blockedRequests = results.filter(r => !r.allowed)

      // Should block most requests
      expect(allowedRequests.length).toBeLessThanOrEqual(10)
      expect(blockedRequests.length).toBeGreaterThan(80)
    })

    it('should handle distributed rate limiting', async () => {
      const identifier = 'distributed-test-user'
      const instances = ['instance-1', 'instance-2', 'instance-3']

      // Test rate limiting across multiple instances
      for (const instance of instances) {
        const result = await RateLimiter.checkDistributedRateLimit(
          identifier,
          {
            windowMs: 60000,
            maxRequests: 5
          },
          instance
        )
        
        expect(result.allowed).toBe(true)
        expect(result.limit).toBe(5)
      }
    })
  })

  describe('Data Exposure Prevention', () => {
    it('should not expose sensitive data in API responses', () => {
      const userObject = {
        id: 'user-123',
        email: 'user@example.com',
        username: 'testuser',
        password: 'hashed-password',
        passwordSalt: 'salt-value',
        apiKey: 'secret-api-key',
        internalNotes: 'Internal admin notes',
        creditCardNumber: '4532-1234-5678-9012',
        ssn: '123-45-6789'
      }

      const sanitizedUser = sanitizeUserForResponse(userObject)

      // Should not expose sensitive fields
      expect(sanitizedUser).not.toHaveProperty('password')
      expect(sanitizedUser).not.toHaveProperty('passwordSalt')
      expect(sanitizedUser).not.toHaveProperty('apiKey')
      expect(sanitizedUser).not.toHaveProperty('internalNotes')
      expect(sanitizedUser).not.toHaveProperty('creditCardNumber')
      expect(sanitizedUser).not.toHaveProperty('ssn')

      // Should expose safe fields
      expect(sanitizedUser).toHaveProperty('id')
      expect(sanitizedUser).toHaveProperty('email')
      expect(sanitizedUser).toHaveProperty('username')
    })

    it('should mask sensitive data in logs', () => {
      const logData = {
        userId: 'user-123',
        action: 'login_attempt',
        email: 'user@example.com',
        password: 'user-password',
        creditCard: '4532-1234-5678-9012',
        ssn: '123-45-6789',
        ipAddress: '192.168.1.1'
      }

      const maskedLog = maskSensitiveLogData(logData)

      expect(maskedLog.password).toBe('[REDACTED]')
      expect(maskedLog.creditCard).toBe('4532-****-****-9012')
      expect(maskedLog.ssn).toBe('***-**-6789')
      expect(maskedLog.email).toBe('u***@example.com')
      expect(maskedLog.ipAddress).toBe('192.168.1.***')
    })

    it('should validate environment variable exposure', () => {
      const dangerousEnvVars = [
        'DATABASE_PASSWORD',
        'JWT_SECRET',
        'API_SECRET_KEY',
        'PRIVATE_KEY',
        'SUPABASE_SERVICE_ROLE_KEY'
      ]

      // These should never be exposed to client-side
      dangerousEnvVars.forEach(envVar => {
        // Mock checking if env var is exposed in client bundle
        const isExposedToClient = envVar.startsWith('NEXT_PUBLIC_')
        expect(isExposedToClient).toBe(false)
      })

      const safeEnvVars = [
        'NEXT_PUBLIC_SUPABASE_URL',
        'NEXT_PUBLIC_APP_NAME', 
        'NEXT_PUBLIC_VERSION'
      ]

      safeEnvVars.forEach(envVar => {
        const isExposedToClient = envVar.startsWith('NEXT_PUBLIC_')
        expect(isExposedToClient).toBe(true)
      })
    })
  })

  describe('Game Integrity and Anti-Cheating', () => {
    it('should validate poker game actions', () => {
      const gameState = {
        currentPlayer: 'player1',
        currentBet: 20,
        playerChips: { player1: 100, player2: 200 },
        minRaise: 20,
        phase: 'preflop'
      }

      const validActions = [
        { playerId: 'player1', action: 'fold' },
        { playerId: 'player1', action: 'call', amount: 20 },
        { playerId: 'player1', action: 'raise', amount: 40 }
      ]

      const invalidActions = [
        { playerId: 'player2', action: 'fold' }, // Not current player
        { playerId: 'player1', action: 'raise', amount: 10 }, // Below minimum
        { playerId: 'player1', action: 'raise', amount: 200 }, // Above available chips
        { playerId: 'player1', action: 'check' } // Can't check when there's a bet
      ]

      validActions.forEach(action => {
        const isValid = validatePlayerAction(action, gameState)
        expect(isValid).toBe(true)
      })

      invalidActions.forEach(action => {
        const isValid = validatePlayerAction(action, gameState)
        expect(isValid).toBe(false)
      })
    })

    it('should prevent timing attacks on card dealing', () => {
      const dealingTimes: number[] = []

      // Simulate multiple card dealing operations
      for (let i = 0; i < 100; i++) {
        const startTime = performance.now()
        
        // Mock card dealing (should take consistent time)
        const cards = dealCards(2) // Deal 2 cards
        
        const endTime = performance.now()
        dealingTimes.push(endTime - startTime)
      }

      // Calculate timing statistics
      const avgTime = dealingTimes.reduce((a, b) => a + b, 0) / dealingTimes.length
      const maxTime = Math.max(...dealingTimes)
      const minTime = Math.min(...dealingTimes)
      const timingVariance = maxTime - minTime

      // Timing should be consistent (variance < 5ms)
      expect(timingVariance).toBeLessThan(5)
    })

    it('should validate hand history integrity', () => {
      const handHistory = {
        handId: 'hand-123',
        gameId: 'game-456',
        players: ['player1', 'player2'],
        actions: [
          { player: 'player1', action: 'raise', amount: 20, timestamp: '2023-01-01T10:00:00Z' },
          { player: 'player2', action: 'call', amount: 20, timestamp: '2023-01-01T10:00:01Z' }
        ],
        result: { winner: 'player1', pot: 40 },
        checksum: 'abc123def456'
      }

      // Verify hand history hasn't been tampered with
      const calculatedChecksum = calculateHandChecksum(handHistory)
      expect(calculatedChecksum).toBe(handHistory.checksum)

      // Test with tampered data
      const tamperedHistory = {
        ...handHistory,
        result: { winner: 'player2', pot: 40 } // Changed winner
      }
      
      const tamperedChecksum = calculateHandChecksum(tamperedHistory)
      expect(tamperedChecksum).not.toBe(handHistory.checksum)
    })

    it('should prevent collusion detection bypasses', () => {
      const suspiciousPatterns = [
        {
          pattern: 'frequent_folding',
          players: ['player1', 'player2'],
          description: 'Players frequently fold to each other'
        },
        {
          pattern: 'chip_dumping',
          players: ['player3', 'player4'],
          description: 'One player consistently loses to another'
        },
        {
          pattern: 'synchronized_actions',
          players: ['player5', 'player6'],
          description: 'Players have suspiciously similar action timings'
        }
      ]

      suspiciousPatterns.forEach(pattern => {
        const riskScore = calculateCollusionRisk(pattern)
        expect(riskScore).toBeGreaterThan(0)
        expect(riskScore).toBeLessThanOrEqual(100)
        
        if (riskScore > 80) {
          // High risk should trigger investigation
          expect(flagForInvestigation(pattern)).toBe(true)
        }
      })
    })
  })
})

// Helper functions (would be implemented in actual security module)
function validateJWT(token: string): boolean {
  if (!token || token.length === 0) return false
  if (token === 'Bearer ') return false
  if (token.length > 500) return false // Prevent oversized tokens
  if (token.includes('eyJhbGciOiJub25lIi')) return false // Reject 'none' algorithm
  return true // Simplified validation
}

function sanitizeUserForResponse(user: any): any {
  const { password, passwordSalt, apiKey, internalNotes, creditCardNumber, ssn, ...safeUser } = user
  return safeUser
}

function maskSensitiveLogData(data: any): any {
  const masked = { ...data }
  
  if (masked.password) masked.password = '[REDACTED]'
  if (masked.creditCard) {
    masked.creditCard = masked.creditCard.replace(/(\d{4})-(\d{4})-(\d{4})-(\d{4})/, '$1-****-****-$4')
  }
  if (masked.ssn) {
    masked.ssn = masked.ssn.replace(/(\d{3})-(\d{2})-(\d{4})/, '***-**-$3')
  }
  if (masked.email) {
    masked.email = masked.email.replace(/(.)[^@]*(@.*)/, '$1***$2')
  }
  if (masked.ipAddress) {
    masked.ipAddress = masked.ipAddress.replace(/(\d+\.\d+\.\d+)\.\d+/, '$1.***')
  }
  
  return masked
}

function sanitizeFileName(fileName: string): string {
  return fileName
    .replace(/[<>:"/\\|?*]/g, '') // Remove dangerous characters
    .replace(/\.\./g, '')          // Remove path traversal
    .replace(/\.(exe|bat|com|scr|pif)$/i, '.txt') // Change dangerous extensions
    .substring(0, 255)             // Limit length
}

function validatePlayerAction(action: any, gameState: any): boolean {
  if (action.playerId !== gameState.currentPlayer) return false
  
  if (action.action === 'raise') {
    if (action.amount < gameState.minRaise) return false
    if (action.amount > gameState.playerChips[action.playerId]) return false
  }
  
  if (action.action === 'check' && gameState.currentBet > 0) return false
  
  return true
}

function dealCards(count: number): string[] {
  // Mock consistent timing for card dealing
  const startTime = Date.now()
  const cards = Array.from({ length: count }, (_, i) => `card-${i}`)
  
  // Ensure consistent timing (prevent timing attacks)
  while (Date.now() - startTime < 2) {
    // Wait for consistent 2ms
  }
  
  return cards
}

function calculateHandChecksum(handHistory: any): string {
  // Mock checksum calculation
  const data = JSON.stringify({
    handId: handHistory.handId,
    actions: handHistory.actions,
    result: handHistory.result
  })
  
  // In real implementation, use cryptographic hash
  return btoa(data).substring(0, 12)
}

function calculateCollusionRisk(pattern: any): number {
  // Mock collusion risk calculation
  const riskFactors = {
    frequent_folding: 60,
    chip_dumping: 85,
    synchronized_actions: 75
  }
  
  return riskFactors[pattern.pattern as keyof typeof riskFactors] || 0
}

function flagForInvestigation(pattern: any): boolean {
  return calculateCollusionRisk(pattern) > 80
}